<!-- head -->

<title>(identity 'quasilyte)</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="../assets/css/pure/pure-min.css">
<link rel="stylesheet" href="../assets/css/style.css">
<script src="../assets/js/jquery/jquery.min.js"></script>
<script src="../assets/js/underscore/underscore.min.js"></script>
<script src="../assets/js/init.js"></script>
<script src="../assets/js/post.js"></script>
<script src="../assets/js/posts_data.js"></script>
<script src="../assets/js/post_init.js"></script>
<script src="../assets/js/rich_content.js"></script>

<!-- body -->

<div id="header" class="header"></div>
<div id="post-info"></div>

<div class="box">
  <h3 class="chapter"><a name="about">What is "Raaagf!" about</a></h3>

  <p class="rich">
    {Ragf} is easy to embed low level language
    which can be expressed in many programming languages as [EDSL:EDSL].
    It is designed to be integrated inside very high level languages like 
    Ruby, Perl6 and Lisp. Its perfomance rivals native code,
    so the main purpose of using Ragf is to sped up 
    application hot spots. 
    Because most frontends done as EDSL, 
    user can mix both Ragf code & host language to achieve 
    better flexibility while still getting all benefits from IDE.
  </p>

  <p class="rich">
    Below you can find a tiny example of Ruby DSL.
    For more comprehensve description [RubyDSL:hit this link].
  </p>

  <pre id="snippet1" title="Ruby DSL" class="snippet"></pre>

  <p>
    Once compiled, code can be executed as many times as needed.
    Compilation itself does not require any heavy computations
    or external process spawning. 
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="design">Project design</a></h3>
  
  <p>
    There are 2 essential parts: compiler and target lenguage API.
  </p>

  <p class="rich">
    Compiler is used by all embedded Ragf implementations.
    Specific language API can be expressed via DSL or 
    some variation of [Fluent:fluent interface].
    The former can be called backend, the latter is frontend.
  </p>

  <p>
    The purpose of DSL is to prepare binary representation
    of Ragf language for the compiler.
    Compiler uses generated bytes and converts them into
    executable machine code.
  </p>

  <p>
    Because compiler does not depend on the particular
    frontend, one can save binary representation produced
    by the X language and run that chunk inside Y language.
  </p>

  <p>
    Frontends can provide very different interfaces to
    Ragf, there is no standard syntax or other enforcements/requirements. 
    It is also possible for multiple interfaces to
    exist inside one host language. They can even vary in
    amounts of abstractions provided.
  </p>

  <p>
    Ragf mostly evolves in direction of more optimizations
    from backend; additional supported CPU architercures
    and other non-breaking internal changes.
    Public API will be stabilized soon.
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="aspects">Key aspects</a></h3>

  <p>
    1) Easy binary format. The aim is to make frontend
    development as easy as possible to support higher 
    number of execution environments. 
  </p>

  <p>
    2) Instruction set must be both convenient and 
    efficient: underlying machine quirks are avoided,
    API provides interface which is optimization friendly.
  </p>

  <p>
    3) No jumps/goto. Ragf provides many flow control structures:
    loops, conditional if/else, switch and table dispatcher.
    It is also possible to call C functions from Ragf.
    Several popular calling conventions are available.
  </p>

  <p>
    4) Being low level. Programmer maps his data directly 
    in the hardware registers and uses indirect addressing
    for memory operations. Ragf is closer to the metal than C.
  </p>

  <p>
    5) No feature bloat. All optional stuff should be moved
    to contrib repositories. Core should be very lightweight.
  </p>
</div>

<div id="footer"></div>

<script id="snippet1-src" type="text/template">
steps = 10 

code = Ragf.compile {
  # Any Ruby code can be used inside this block.
  # Some constructs has special meaning, like in any DSL.

  name r[0], :counter
  name r[1], :result
  WHILE counter < steps {
    counter += 1
    result -= 2
  } 
  RETURN result
}
result = Ragf.run code # => -20  
</script>

<script>
  App.enrichContent({
    "EDSL": "https://en.wikipedia.org/wiki/Domain-specific_language",
    "Fluent": "https://en.wikipedia.org/wiki/Fluent_interface",
    "RubyDSL": "https://github.com/Quasilyte/RAGF/blob/master/docs/dsl/ruby_dsl.rb"
  });
</script> 