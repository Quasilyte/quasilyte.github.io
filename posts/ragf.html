<!-- head -->

<title>(identity 'quasilyte)</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="../assets/css/pure/pure-min.css">
<link rel="stylesheet" href="../assets/css/style.css">
<script src="../assets/js/jquery/jquery.min.js"></script>
<script src="../assets/js/underscore/underscore.min.js"></script>
<script src="../assets/js/init.js"></script>
<script src="../assets/js/post.js"></script>
<script src="../assets/js/posts_data.js"></script>
<script src="../assets/js/post_init.js"></script>
<script src="../assets/js/rich_content.js"></script>

<!-- body -->

<div id="header" class="header"></div>
<div id="post-info"></div>

<div class="box">
  <h3 class="chapter"><a name="aspects">JIT it manually</a></h3>

  <p class="rich">
    Before [JIT:JIT] compilers became popular, there were only one
    way to make something that runs fast: translate it 
    into machine code ahead of time using only static information.
    Code interpretation is slow without just in time compilation;
    you just can not build anything that outperforms native format
    for the fastest interpreter possible - CPU itself.
  </p>

  <p class="rich">
    The project described in this post is somewhere between 
    JIT and [AOT:AOT]: during execution,
    its compiled into machine code,
    but each operation can have value that is bound using 
    run time variable. More than that, using conditionals we can
    leave some code uncompiled at all.
  </p>

  <p>
    Manual dynamic compilation has several advantages 
    over sophisticated JIT engines:

    <ul>
      <li>
        Less dependencies on non-determined optimizations
        that may vary or even absent on many platforms
      </li>

      <li>
        It easier to integrate because of unobtrusive nature
        of Ragf. No need for tight cooperation with the evaluator
      </li>

      <li>
        Far more explicit; no hidden costs (performance-wise)
      </li>

      <li>
        Lightweight and straightforward
      </li>
    </ul>
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="about">What is "Raaagf!" about</a></h3>

  <p class="rich">
    {Ragf} is easy to embed low level language
    which can be expressed in many programming languages as [EDSL:EDSL].
    It is designed to be integrated inside Ruby, Perl6, Lisp and others.
    Ragf perfomance is on par with native code, therefore
    its main purpose is to sped up application hot spots.
    Because most frontends are done as EDSL, 
    user can mix both Ragf code & host language to achieve 
    better flexibility while still getting all benefits from IDE.
  </p>

  <p class="rich">
    Below you can find a tiny example of Ruby DSL.
    For more comprehensve description hit [RubyDSL:this link].
  </p>

  <pre id="snippet1" title="Ruby DSL" class="snippet"></pre>

  <p>
    Once compiled, code can be executed as many times as needed.
    Compilation itself does not require any heavy computations
    or external process spawning. 
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="design">Project design</a></h3>
  
  <p>
    There are 2 essential parts: compiler and target language API.
  </p>

  <p class="rich">
    Compiler is used by all embedded Ragf implementations.
    Specific language API can be expressed via DSL or 
    some variation of [Fluent:fluent interface].
    The former can be called backend, the latter is frontend.
  </p>

  <p>
    The purpose of DSL is to prepare binary representation
    of Ragf language for the compiler.
    Compiler uses generated bytes and converts them into
    executable machine code.
  </p>

  <p>
    Because compiler does not depend on the particular
    frontend, one can save binary representation produced
    by the X language and run that chunk inside Y language.
  </p>

  <p>
    Frontends can provide very different interfaces to
    Ragf, there is no standard syntax or other enforcements/requirements. 
    It is also possible for multiple interfaces to
    exist inside one host language. They can even vary in
    amounts of abstractions provided.
  </p>

  <p>
    Ragf mostly evolves in direction of more optimizations
    from backend; additional supported CPU architercures
    and other non-breaking internal changes.
    Public API will be stabilized soon.
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="aspects">Key aspects</a></h3>

  <p>
    Each aspect is listed as if it is already satisfied.
    They are rules that drive project. They define Ragf.
  </p>

  <p>
    1) Easy binary format. The aim is to make frontend
    development as easy as possible to support higher 
    number of execution environments. 
  </p>

  <p>
    2) Instruction set is both convenient and 
    efficient: underlying machine quirks are avoided,
    API provides interface which is optimization friendly.
  </p>

  <p>
    3) No jumps/goto. Ragf provides many flow control structures:
    loops, conditional if/else, switch and table dispatcher.
    It is also possible to call C functions from Ragf.
    Several popular calling conventions are available.
  </p>

  <p>
    4) Low level. Programmer maps his data directly 
    into hardware registers and uses indirect addressing
    for memory operations. Ragf is closer to the metal than C.
  </p>

  <p>
    5) No feature bloat. All optional stuff moved
    to contrib repositories. 
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="lang">Deliberate limitations</a></h3>

  <p>
    It is important to note that Ragf is not that useful 
    outside host language. Here are few reasons why: 

    <ul>
      <li>
        No way to allocate dynamic memory. 
        Ragf code can only access preallocated data segment which
        is provided by the callee.
      </li>

      <li>
        No builtin macro system; It depends on the containing
        language capabilities for this. For example, macro
        can be implemented as a simple function returning
        piece of Ragf code; if/else can be
        used to achieve conditional compilation; variables/constants can
        be used for parametrization and argument passing.
      </li>

      <li>
        It shares many drawbacks of the assembly languages. 
        Main codebase should be written in 
        host language and only parts that require tons of 
        CPU cycles could be rewritten Ragf.
      </li>
    </ul>
  </p>

  <p>
    Everything listed above is a design choice.
    Ragf adds minimal cognitive load on the programmer;
    it takes as many constructs from familiar languages 
    as possible.
  </p>
</div>

<div id="footer"></div>

<script id="snippet1-src" type="text/template">
steps = 10 

code = Ragf.compile {
  # Any Ruby code can be used inside this block.
  # Some constructs has special meaning, like in any DSL.

  name r[0], :counter
  name r[1], :result
  WHILE counter < steps {
    counter += 1
    result -= 2
  } 
  RETURN result
}
result = Ragf.run code # => -20  
</script>

<script>
  App.enrichContent({
    "JIT": "https://en.wikipedia.org/wiki/Just-in-time_compilation",
    "AOT": "https://en.wikipedia.org/wiki/Ahead-of-time_compilation",
    "EDSL": "https://en.wikipedia.org/wiki/Domain-specific_language",
    "Fluent": "https://en.wikipedia.org/wiki/Fluent_interface",
    "RubyDSL": "https://github.com/Quasilyte/RAGF/blob/master/docs/dsl/ruby_dsl.rb"
  });
</script> 
