<!-- head -->

<title>(identity 'quasilyte)</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="../assets/css/pure/pure-min.css">
<link rel="stylesheet" href="../assets/css/style.css">
<script src="../assets/js/jquery/jquery.min.js"></script>
<script src="../assets/js/underscore/underscore.min.js"></script>
<script src="../assets/js/init.js"></script>
<script src="../assets/js/post.js"></script>
<script src="../assets/js/posts_data.js"></script>
<script src="../assets/js/post_init.js"></script>
<script src="../assets/js/rich_content.js"></script>

<!-- body -->

<div id="header" class="header"></div>
<div id="post-info"></div>

<div class="box">
  <h3 class="dark-box">Nbody</h3>

  <p class="rich">
    {Ragf} has no support for floating point type yet.
    To do them right I need an example of their usage in
    tight calculations. 

    [Nbody:Nbody] programming task consists of 80% floating point
    arithmetics. No allocations, no external libraries needed, 
    only number crunching, which is good.
  </p>

  <p class="rich">
    [DSL:Ruby DSL] is going to be the first one released, so the plan is:
    <ol>
      <li class="rich">Rewrite [RubyNbody:this] ruby code in x86_64 asm</li>
      <li>Compare its perfomance with top programs and optimize it</li>
      <li class="rich">Use earned knowledge in {Ragf} design</li>
    </ol>
  </p>
</div>

<br>

<div class="box">
  <h3 class="dark-box">First attempts</h3>

  <p>
    The good thing about Ruby program: expressions are manually
    optimized; common subexpressions are saved into locals and reused.
    Nasm (chosen assembler), like other assemblers, will not optimize
    redundant calculations. Ruby program algorithm is a good starting point. 
  </p>

  <p>
    The ruby->asm translation was rather trivial.
    Resultive code is a big chunk of arithmetics, data moves and 
    function calls. When it was done, I measured execution time.
  </p>

  <table class="pure-table pure-table-horizontal">
    <tr class="dark-color2">
      <th>Implementation</th>
      <th>Time elapsed</th>
    </tr>
    <tr>
      <td>Ruby</td>
      <td>2.900s</td>
    </tr>
    <tr>
      <td>Nasm</td>
      <td>0.180s</td>
    </tr>
    <tr>
      <td>Go</td>
      <td>0.070s</td>
    </tr>
  </table>

  <p class="rich">
    Produced program is more than 2 times slower than [GoNbody:Go version].
    Both compiled straight to machine code and gcgo is known
    for its weak optimizations (but SSA backend made things better).
    If Go compiler achieved that speed, it is possible to improve 
    my initial code. Most significant optimizations I made
    are explained below.
  </p>
</div>

<br>

<!--
  * destructuring arith
  * use pointer seq instead of counter
  * combine lea+add/sub
  * specialize algorithms 

  not work:
  * instruction grouping
  -->

<div class="box">
  <h3 class="dark-box">???</h3>

  <p>
    In high level language like C you define functions
    very frequently. You know that this is nearly free
    abstraction, because compiler could inline function
    instead of invoking it => you get reusable code chunks 
    for a very low price.
  </p>

  <pre id="snippet4" title="HLL function" class="snippet"></pre>

  <p>
    But it is not call instruction that makes function
    invocation slow. Before function is called, callee side must
    preserve resigters it needs to avoid data clobbering.
    Even more, when function body is not inlined many optimization
    opportunities are lost. What I want to tell is that
    assembler "functions" are far less useful.
    They can never be inlined. 
  </p>

  <pre id="snippet5" title="LLL function" class="snippet"></pre>

  <p>
    Now suppose you have code that calls this dx function.
    Most likely it has a.x and b.y values in registers already.
    But you can not use them, because function has other 
    calling expectations. It receives 2 pointers.
    
  </p>
</div>

<div class="box">
  <h3 class="dark-box">A - aligned memory access</h3>

  <p>
    Number one optimization tip is...
    Use the correct MOV instructions!
    There are many SSE instructions to move data
    between memory and registers. Some of them
    are much faster than others when special
    conditions met.
  </p>

  <pre id="snippet1" title="MOV variants" class="snippet"></pre>

  <p>
    So, I replaced each reg->reg movsd with movapd and this change alone
    gave initial program about 70% perfomance boost.
    I still had many unaligned memory accesses and most of them
    are inside nested loops. The nature solution to this is structure
    unpacking (but we need many free registers).
  </p>

  <pre id="snippet2" title="Bad pattern" class="snippet"></pre>

  <p>
    We iterate over objects X from $begin until the $end using the same object Y
    which address is stored in rdi register. If there is no register pressure 
    inside loop body, we can use spare registers to store unpacked values. 
    Now the execution time dropped down to 0.60-0.65s. 
    On par with Go already.
  </p>

  <pre id="snippet3" title="Good pattern" class="snippet"></pre>
</div>


<br>

<div class="box">
  <h3 class="dark-box">Some tricks are not worth it</h3>
</div>

<br>

<div class="box">
  <h3 class="dark-box">Ragf update</h3>

  <p>
    #TODO    
  </p>
</div>

<div id="footer"></div>

<script id="snippet1-src" type="text/template">
;; Let xmm0 and xmm1 contain float64 values
movsd xmm0, xmm1  ;; Wrong! 
movapd xmm0, xmm1 ;; Better. "a" for "aligned", green light
movsd xmm0, [rax] ;; OK if we can not guarantee alignment 
</script>

<script id="snippet2-src" type="text/template">
;; N = ($end - $begin) / Body.size
mov rsi, $begin
loop_body:
  addsd xmm0, [rdi + Body.x] ;; N memory accesses
  movsd xmm1, [rdi + Body.y] ;; N memory accesses, 2N in so far
  ;; ... some more code which uses struct fields
  add rsi, Body.size
loop_check:
  cmp rsi, $end
  jne loop_body 
</script>

<script id="snippet3-src" type="text/template">
mov xmm7, [rdi + Body.x] 
mov xmm6, [rdi + Body.y]
mov rsi, $begin
loop_body:
  addsd  xmm0, xmm7 
  movapd xmm1, xmm6 ;; can use movapd now
  ;; ... you get the idea
</script>

<script id="snippet4-src" type="text/template">
// This function will be inlined and you get no 
// additional overhead by using it instead of repeating
// code everywhere you need to calculate dx.
func dx(a, b *Body) float64 {
  return a.x - b.x
}
</script>

<script id="snippet5-src" type="text/template">
;; Never inlined, never optimized, always uses 3 registers
dx:
  movsd xmm0, [rdi + Body.x]
  subsd xmm0, [rsi + Body.x]
  ret
</script>

<script>
  var benchmarksgameUrl = "http://benchmarksgame.alioth.debian.org/";
  App.enrichContent({
    "DSL": "https://github.com/Quasilyte/RAGF/blob/master/docs/dsl/ruby_dsl.rb",
    "Nbody": `${benchmarksgameUrl}/u64q/nbody-description.html#nbody`,
    "RubyNbody": `${benchmarksgameUrl}/u64q/program.php?test=nbody&lang=jruby&id=2`,
    "GoNbody": `${benchmarksgameUrl}/u64q/program.php?test=nbody&lang=go&id=1`
  });
</script> 