<!-- head -->

<title>(identity 'quasilyte)</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="../assets/css/pure/pure-min.css">
<link rel="stylesheet" href="../assets/css/style.css">
<script src="../assets/js/jquery/jquery.min.js"></script>
<script src="../assets/js/underscore/underscore.min.js"></script>
<script src="../assets/js/init.js"></script>
<script src="../assets/js/post.js"></script>
<script src="../assets/js/posts_data.js"></script>
<script src="../assets/js/post_init.js"></script>
<script src="../assets/js/rich_content.js"></script>

<!-- body -->

<div id="header" class="header"></div>
<div id="post-info"></div>

<div class="box">
  <h3 class="chapter"><a name="state">State of the C</a></h3>

  <p>
    C fits its niche quite well.
    If you want relatively simple, ubiquitous and efficient language
    there is no much room for selection.
  </p>

  <p>
    Many people, me included, find that C is quite complete.
    This is one the reasons why it "evolves so slowly".
    The only parts that could be improved without making C
    yet another bloated language require breaking changes.
    C will never break backwards compatibility, so we are stuck.
    We stuck in a good sense, having a mature,
    stable programming language is a good thing.
    But C could be designed better; there is some room for improvement.
  </p>

  <p>
    In this post I will try to enumerate and explain
    my rants towards C.
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="mutability">Mutability defaults</a></h3>

  <p>
    Programming language should force you to think about
    your code more thoroughly. Whenever there is a choice,
    the most safe and strict choice should be favoured for a default.
  </p>

  <p class="rich">
    Mutable state must have explicit eye-catcher.
    We generally should care more about marking potentially
    tricky code rather than const-correct code ([Rust:Rust language] also takes
    this approach).
  </p>

  <p>
    <span class="bold">
      All variables and aggregate type members should be immutable by default.
    </span>
  </p>

  <div class="pure-g">
    <div class="pure-u-1-2">
      <pre id="mutability-bad" title="This is bad" class="snippet"></pre>
    </div>
    <div class="pure-u-1-2">
      <pre id="mutability-good" title="This is good" class="snippet"></pre>
    </div>    
  </div>

  <p>
    Compiler should warn if the variable marked as mutable,
    but needs not to be.
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="tag_name">Tag names</a></h3>

  <p>
    There could be a rationale for separate "namespace" for user-defined
    types like structs, unions and enums.
    C has no real namespaces, so if we put everything into single
    symbol table it will bloat and compilation time can increase
    marginally. 
  </p>

  <p class="rich">
    Everything is fine except that 90% of people instantly typedef
    anonymous structs. Or, if they want to be able to forward
    declare it inside other header, [Typedef:smarter typedef is done].
    This leads us to registering same symbol inside two tables.
    Not only this is not convenient, it is also inefficient.
  </p>

  <p>
    <span class="bold">
      User defined types should have real name, not merely tag.
    </span>
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="multi_decls">Multiple variable declarations</a></h3>

  <p>
    Multiple declarations on the same line do not improve code readability.
    C is not about typing fewer keywords,
    I see no gain in using this syntax.
    They can also lead for confusion among amateurs.
  </p>

  <p>
    <span class="bold">
      Declaring multiple variables in one statement should be forbidden.
    </span>
  </p>

  <p>
    <pre id="multi_decls-bad" title="This is bad" class="snippet"></pre>
    <pre id="multi_decls-good" title="This is good" class="snippet"></pre>
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="builtins">Builtin types</a></h3>

  <p>
    More builtin primitive types would be convenient.
    Language would feel more coherent if things like size_t,
    int32_t and bool were builtin.
    Currently, we must include at least 3 headers to have most
    of the useful primitive types: "stddef.h" for size_t,
    "stdint.h" for fixed width types and "stdbool.h" to
    avoid ugly _Bool.
  </p>
  
  <p>
    <span class="bold">
      Most useful primitive types should be builtin.
    </span>
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="builtins">Array decay</a></h3>

  <p class="rich">
    If you want to pass an "array" of known length,
    [Decay:C provides no help for that].
    You can try [Cello:something like this],
    but then you lose an ability
    to pass sub-arrays without copying (address plus offset). 
  </p>
  
  <p>
    Most projects I have ever seen define some kind of "fat pointer"
    structure. That is, structure of {void*, size_t}.
    The problem is: this structure is vital, universal and useful,
    but it is missing from the standard library =&gt;
    every project defines their own fat pointer.
    Who stole my "stdarray.h"?
  </p>
  
  <p>
    <span class="bold">
      Arrays with length must be better supported by the language.
    </span>
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="aliasing">Aliasing defaults</a></h3>

  <p class="rich">
    This is harder to get right, but I believe it is possible to
    make pointers "restrict" by default while providing "alias"
    keyword to mark pointers of the same type that can overlap.
    Just like in case of const-by-default, language should favor
    more restrictive defaults. 
  </p>

  <p>
    <span class="bold">
      All pointers are restrict-qualified by default.
    </span>
  </p>

  <p>
    <pre id="aliasing-bad" title="This is bad" class="snippet"></pre>
    <pre id="aliasing-good" title="This is good" class="snippet"></pre>
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="stmt">Statement-orientation</a></h3>

  <p>
    Expression-oriented languages are simple put, more expressive.
    There is no runtime cost because compiler can easily determine
    whenever particular construct is used inside lvalue context.
  </p>

  <p>
    <span class="bold">
      Expression-oriented is better than statement-oriented
    </span>
  </p>

  <div class="pure-g">
    <div class="pure-u-1-2">
      <pre id="stmt-bad" title="This is bad" class="snippet"></pre>
    </div>
    <div class="pure-u-1-2">
      <pre id="stmt-good" title="This is good" class="snippet"></pre>
    </div>    
  </div>

  <p class="rich">
    One can argue that you can define separate function which
    uses same switch, but returns necessary value.
    This helps to avoid ugly "break", but introduces a new function.
    Other solution is to use [Ternary:conditional operator].
    When formatted properly, it emulates "case" expression well.
    Too bad I have yet to see a compiler that checks controlling
    expressions to be in sequential order (like enum constants)
    to perform optimizations akin to switch.
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="more">To be continued</a></h3>

  <p>
    I have not yet covered dumb preprocessor,
    ambigious and clumsy syntax,
    inabillity to initialize global const data in non-trivial way
    at compile time and some other things I dislike in C.
  </p>

  <p>Updates coming soon.</p>
</div>

<div id="footer"></div>

<script id="mutability-bad-src" type="text/template">
/// BAD 
/* Header */
typedef struct Str Str;
struct Str {
  const char* data;
  size_t len;
};

bool str_eq(const Str* a, const Str* b);
void str_copy(Str* dst, const Str* src);

/* Source */
bool str_eq(const Str* const a,
            const Str* const b);
void str_copy(Str* dst, const Str* src);
</script>
<script id="mutability-good-src" type="text/template">
/// GOOD 
/* Header */
typedef struct Str Str;
struct Str {
  char* mutable data;
  mutable size_t len;
};

bool str_eq(Str* a, Str* b);
void str_copy(mutable Str* dst, Str* src);

/* Source */
bool str_eq(Str* a, Str* b);
void str_copy(mutable Str* mutable dst,
              Str* mutable src);
</script>

<script id="multi_decls-bad-src" type="text/template">
/// BAD 
int *x, *y, z;
</script>
<script id="multi_decls-good-src" type="text/template">
/// GOOD 
int* x;
int* y;
int z;
</script>

<script id="aliasing-bad-src" type="text/template">
/// BAD 
void copy(char* restrict dst, char* restrict src);
void move(char* dst, char* src);
</script>
<script id="aliasing-good-src" type="text/template">
/// GOOD 
void copy(char* dst, char* src);
void move(char* alias dst, char* alias src);
</script>

<script id="stmt-bad-src" type="text/template">
void BAD(ErrorCode code) {
  switch (code) {
  case E_FOO:
    puts("foo error!");
    break;
  case E_BAR:
    puts("bar error!");
    break;
  default:
    puts("unknown error!");
  }
}
</script>
<script id="stmt-good-src" type="text/template">
void GOOD(ErrorCode code) {
  puts(switch_expr (code) {
    case E_FOO: "foo error!";
    case E_BAR: "bar error!";
    default: "unknown error!";
  });
}
</script>

<script>
  App.enrichContent({
    "Rust": "https://www.rust-lang.org",
    "Typedef": "http://www.embedded.com/electronics-blogs/programming-pointers/4024450/Tag-vs-Type-Names",
    "Decay": "http://www.drdobbs.com/architecture-and-design/cs-biggest-mistake/228701625",
    "Cello": "http://libcello.org/learn/a-fat-pointer-library",
    "Ternary": "https://en.wikipedia.org/wiki/%3F:"
  });
</script> 
