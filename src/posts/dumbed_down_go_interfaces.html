<!-- head -->

<title>Dumbed-down Go interfaces</title>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="style.css">
<script src="post.js"></script>

<!-- body -->

<div id="header" class="header"></div>
<div id="post-info"></div>

<div class="box">
  <h3 class="chapter"><a name="io-writer">io.Writer interface</a></h3>
    
  <p>
    If you write Go there are good odds you know io.Writer#Write 
    signature well. Write returns both error and number of bytes written.
    Every time you call this method, error should be checked before you 
    try to write to that writer again.
  </p>

  <p>
    This interface is inconvenient to 
    use when you want to call Write multiple times and get 
    total number of bytes pushed during these invocations.
    You also do not want to loose error if it ever occurs.
  </p>

  <p>
    <pre id="io-writer" title="Idiomatic Go" class="snippet"></pre>
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="dumbing_down">Dumbing down</a></h3>

  <p>
    Code presented above contains to much details about well-known 
    operations. Good news: it can be improved and there is even 
    more than one way to do so.
  </p>

  <p>
    Basically, we do two things (except writing): counting bytes 
    and checking errors. 
    To dumb down interface we need to wrap it in concrete type 
    that does additional job for us.
  </p>

  <p>
    I will present two examples that simplify "f1"" function.
    First "f2" does not sacrifice anything but improvement is 
    slight. Second "f3" is more expressive, 
    but may not be always appropriate.
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="without_manual_counting">Without manual counting</a></h3>

  <p>
    If errors are more important than counting, we may wish to hide 
    obscuring code to concentrate on error handling.
  </p>

  <p>
    <pre id="cw" title="countingWriter" class="snippet"></pre>
  </p>

  <p>
    The benefits are: less varibles in scope (no need for temporary "n" 
    and "written" accumulator), single return value makes it easier to 
    compose calls. I see no real disadvantages of this approach.
  </p>

  <p>
    <pre id="f2" title="f2" class="snippet"></pre>
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="without_manual_error_handling">Without manual error handling</a></h3>

  <p>
    We can go further. Explicit error handling in "f1", after all, is not important.
    That function does not try to fix error conditions, it just passes them back to 
    the caller. In the end, "f1" does only one important thing: it writes.
    It is possible to make a write method that returns... nothing.
  </p>

  <p>
    <pre id="sw" title="safeWriter" class="snippet"></pre>
  </p>

  <p>
    Note that even if we do not return an error, we store it in the 
    safeWriter. 
    When first error occurs, safeWriter will continue to look like 
    before, but consequent write calls are ignored.
    After all operations we wish to execute, we return an error 
    (which can be nil) and total number of bytes written.
  </p>

  <p>
    <pre id="f3" title="f3" class="snippet"></pre>
  </p>

  <p>
    This kind of error handling should not be used everywhere.
    Also, using panic on first error is overkill in 
    case of "f1", so I do not consider it as an viable option.
  </p>
</div>

<div id="footer"></div>

<script id="io-writer-src" type="text/template">
func f1(w io.Writer, s fmt.Stringer, parts [][]byte) (int, error) {
	written, err := w.Write([]byte(s.String()))
	if err != nil {
		return written, err
	}
	for _, part := range parts {
		n, err := w.Write(part)
		written += n
		if err != nil {
			return written, err
		}
	}
	return written, nil
}
</script>

<script id="sw-src" type="text/template">
type safeWriter struct {
	err     error
	written int
	dst     io.Writer
}

func (w *safeWriter) SafeWrite(p []byte) {
	if w.err != nil {
		return
	}
	n, err := w.dst.Write(p)
	w.err = err
	w.written += n
}
</script>

<script id="cw-src" type="text/template">
type countingWriter struct {
	written int
	dst     io.Writer
}

func (cw *countingWriter) WriteAndCount(p []byte) error {
	n, err := cw.dst.Write(p)
	cw.written += n
	return err
}
</script>

<script id="f3-src" type="text/template">
func f3(w io.Writer, s fmt.Stringer, parts [][]byte) (int, error) {
	sw := safeWriter{dst: w}
	sw.SafeWrite([]byte(s.String()))
	for _, part := range parts {
		sw.SafeWrite(part)
	}
	return sw.written, sw.err
}
</script>

<script id="f2-src" type="text/template">
func f2(w io.Writer, s fmt.Stringer, parts [][]byte) (int, error) {
	cw := countingWriter{dst: w}
	err := cw.WriteAndCount([]byte(s.String()))
	if err != nil {
		return cw.written, err
	}
	for _, part := range parts {
		err := cw.WriteAndCount(part)
		if err != nil {
			return cw.written, err
		}
	}
	return cw.written, nil
}
</script>

<script>
  App.enrichContent({
  }); 
</script> 