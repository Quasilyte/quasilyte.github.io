<!-- head -->

<title>Broken C defaults</title>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="style.css">
<script src="post.js"></script>

<!-- body -->

<div id="header" class="header"></div>
<div id="post-info"></div>

<div class="box">
  <h3 class="chapter"><a name="state">State of the C</a></h3>

  <p>
    C fits its niche quite well.
    If you want relatively simple, ubiquitous and efficient language
    there is no much room for selection.
  </p>

  <p>
    It "evolves so slowly" because it is already quite complete.
    Most of the parts that can be improved without making C
    yet another bloated language require breaking changes.
  </p>

  <p>
    <span class="bold">
      C could be designed better if we accept older code invalidation
    </span>
  </p>

  <p class="rich">
    ...but in reallity it is impossible to achieve.
    If you are using C, you must know many of its quirks,
    use external static code analyzers and read carefully
    a lots of [CodingStandards:safe coding standards].
  </p>

  <p>
    This post describes subjects that I believe should be
    changed in order to get a better language.
    Note that C is mostly unsafe by design;
    it trusts programmer nearly as much as assemblers do.
    The main target is not making C higher level, but rather
    reconsider the defaults and make best practice enforcements easier.
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="mutability">Mutability defaults</a></h3>

  <p>
    Programming language should force you to think about
    your code more thoroughly. Whenever there is a choice,
    the most safe and strict choice should be favoured for a default.
  </p>

  <p class="rich">
    Mutable state must have explicit eye-catcher.
    We generally should care more about marking potentially
    tricky code rather than const-correct code ([Rust:Rust language] also takes
    this approach).
  </p>

  <p>
    <span class="bold">
      All variables and aggregate type members should be immutable by default.
    </span>
  </p>

  <div class="pure-g">
    <div class="pure-u-1-2">
      <pre id="mutability-bad" title="This is bad" class="snippet"></pre>
    </div>
    <div class="pure-u-1-2">
      <pre id="mutability-good" title="This is good" class="snippet"></pre>
    </div>    
  </div>

  <p>
    Compiler should warn if the variable marked as mutable,
    but needs not to be.
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="tag_name">Tag names</a></h3>

  <p>
    There could be a rationale for separate "namespace" for user-defined
    types like structs, unions and enums.
    C has no real namespaces, so if we put everything into single
    symbol table it will bloat and compilation time can increase
    marginally. 
  </p>

  <p class="rich">
    Everything is fine except that 90% of people instantly typedef
    anonymous structs. Or, if they want to be able to forward
    declare it inside other header, [Typedef:smarter typedef is done].
    This leads us to registering same symbol inside two tables.
    Not only this is not convenient, it is also inefficient.
  </p>

  <p>
    <span class="bold">
      Tag symbols for type names = mistake
    </span>
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="multi_decls">Multiple variable declarations</a></h3>

  <p>
    Multiple declarations on the same line do not improve code readability.
    C is not about typing fewer keywords => no real gain in using this syntax.
    They can also be a source of confusion for amateurs (when they define
    both pointer and non-pointer variables of type T).
  </p>

  <p>
    <span class="bold">
      Declaring multiple variables in one statement should be forbidden.
    </span>
  </p>

  <p>
  </p>

  <div class="pure-g">
    <div class="pure-u-1-2">
      <pre id="multi_decls-bad" title="This is bad" class="snippet"></pre>
    </div>
    <div class="pure-u-1-2">
      <pre id="multi_decls-good" title="This is good" class="snippet"></pre>
    </div>    
  </div>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="builtins">Builtin types</a></h3>

  <p>
    More builtin primitive types would be convenient.
    Language would feel more coherent if things like size_t,
    int32_t and bool were builtin.
    Currently, we must include at least 3 headers to have most
    useful primitive types: "stddef.h" for size_t,
    "stdint.h" for fixed width types and "stdbool.h" to
    avoid ugly _Bool. Predefined NULL of special type
    would be great as well, but this is C++-ism.
  </p>

  <p>
    Talking about breaking existing code, I prefer int32 as a type name
    opposed to int32_t.
  </p>

  <p>
    <span class="bold">
      Most useful primitive types should be builtin.
    </span>
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="builtins">Array decay</a></h3>

  <p class="rich">
    If you want to pass an "array" of known length,
    [Decay:C provides no help for that].
    You can try [Cello:something like this],
    but then you lose an ability
    to pass sub-arrays without copying (address plus offset). 
  </p>
  
  <p>
    Most projects I have ever seen define some kind of "fat pointer"
    structure. That is, structure of {void*, size_t}.
    The problem is: this structure is vital, universal and useful,
    but it is missing from the standard library =&gt;
    every project defines their own fat pointer.
    I demand "stdarray.h".
  </p>

  <p>
    Every homebrew array is incompatible with someone else's array. 
    We end up with two kinds of APIs as a result:
    one which expects two separate arguments
    for data and its length and another which exposes custom array type.
  </p>

  <p>
    As an addition, you will most likely need {void*, size_t, size_t} 
    structure to express fixed-size container that is partially filled.
    This is essential to build extendable arrays (C++ calls them vectors).
    There are many useful fundamental data structures, but we need 
    to start from something. Array seems like a good and easy first step.
  </p>
  
  <p>
    <span class="bold">
      Arrays with length must be better supported by the language.
    </span>
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="aliasing">Aliasing defaults</a></h3>

  <p>
    Additional pointer qualifier is needed to make aliasing 
    possible only with explicit marker.
    If scope has more than one non-const T* then it 
    should be marked either "alias" or "restrict".
    Abscence of qualifier is an error.
  </p>

  <p class="rich">
    If pointers have different type, "restrict" is 
    implied, but this can be redefined by explicit "alias".
    This is needed to avoid breaking of 
    [StrictAliasing:Strict aliasing] rules.
  </p>

  <p>
    <span class="bold">
      There should be more "restrict" and const pointers than 
      mutable and/or aliased pointers.
    </span>
  </p>

  <p>
    <pre id="aliasing-bad" title="This is bad" class="snippet"></pre>
    <pre id="aliasing-good" title="This is good" class="snippet"></pre>
  </p>

  <p class="rich">
    "alias" is choosed as a keyword because GCC already have 
    similar attribute "may_alias" ([GccAlias:link]).
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="stmt">Statement-orientation</a></h3>

  <p>
    Expression-oriented languages are simple put, more expressive.
    There is no runtime cost because compiler can easily determine
    whenever particular construct is used inside lvalue context.
  </p>

  <p>
    <span class="bold">
      Expression-oriented is better than statement-oriented.
    </span>
  </p>

  <p>
    But there is an important exception:
  </p>

  <p>
    <span class="bold">
      Assignments should be statements, not expressions.
    </span>
  </p>

  <div class="pure-g">
    <div class="pure-u-1-2">
      <pre id="stmt-bad" title="This is bad" class="snippet"></pre>
    </div>
    <div class="pure-u-1-2">
      <pre id="stmt-good" title="This is good" class="snippet"></pre>
    </div>    
  </div>

  <p class="rich">
    One can argue that you can define separate function which
    uses same switch, but returns necessary value.
    This helps to avoid ugly "break", but introduces a new function.
    Other solution is to use [Ternary:conditional operator].
    When formatted properly, it emulates "case" expression well.
    Too bad I have yet to see a compiler that checks controlling
    expressions to be in sequential order (like enum constants)
    to perform optimizations akin to switch.
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="constness_erasure">Constness erasure</a></h3>

  <p>
    In modern code, casting away cv-qualifier is almost always a bad idea.
    Potentially, it can lead to undefined behavior.
    As long as const can be casted away, compiler can not make
    strong assumptions about it. Again, this affects both hypothetical
    perfomance and overall language safety.
  </p>

   <p>
    <span class="bold">
      It should be impossible to cast away const quallifiers.
    </span>
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="features">Missing features</a></h3>

  <p>
    This section briefly describes controversial features
    from my wishlist. Completely optional things.
  </p>
  
  <p class="rich">
    Strict/strong typedefs were proposed for C++ more than once
    now. Check [Typedef: this document].
    C could benefit from type-checked typedefs,
    but it can also lead to code pollution with casts if
    used wildly. If you interested in making C code more
    reliable via types, try [CQual:CQual] tool.
  </p>
</div>

<br>

<div class="box">
  <h3 class="chapter"><a name="more">To be continued</a></h3>

  <p>
    I have not yet covered dumb preprocessor,
    ambigious and clumsy syntax,
    inabillity to initialize global const data in non-trivial way
    at compile time and some other things I dislike in C.
  </p>

  <p>Updates are not promised, but possible.</p>
</div>

<div id="footer"></div>

<script id="mutability-bad-src" type="text/template">
/// BAD 
/* Header */
typedef struct Str Str;
struct Str {
  const char* data;
  size_t len;
};

bool str_eq(const Str* a, const Str* b);
void str_copy(Str* dst, const Str* src);

/* Source */
bool str_eq(const Str* const a,
            const Str* const b);
void str_copy(Str* dst, const Str* src);
</script>
<script id="mutability-good-src" type="text/template">
/// GOOD 
/* Header */
typedef struct Str Str;
struct Str {
  mutable char* data;
  mutable size_t len;
};

bool str_eq(Str* a, Str* b);
void str_copy(mutable Str* dst, Str* src);

/* Source */
bool str_eq(Str* a, Str* b);
void str_copy(mutable Str* mutable dst,
              Str* mutable src);
</script>

<script id="multi_decls-bad-src" type="text/template">
/// BAD 
int *x, *y, z;
</script>
<script id="multi_decls-good-src" type="text/template">
/// GOOD 
int* x;
int* y;
int z;
</script>

<script id="aliasing-bad-src" type="text/template">
/// BAD 
void copy(char* restrict dst, char* restrict src);
void move(char* dst, char* src);
</script>
<script id="aliasing-good-src" type="text/template">
/// GOOD 
void copy(char* restrict dst, char* restrict src);
void move(char* alias dst, char* alias src);
</script>

<script id="stmt-bad-src" type="text/template">
void BAD(ErrorCode code) {
  switch (code) {
  case E_FOO:
    puts("foo error!");
    break;
  case E_BAR:
    puts("bar error!");
    break;
  default:
    puts("unknown error!");
  }
}
</script>
<script id="stmt-good-src" type="text/template">
void GOOD(ErrorCode code) {
  puts(switch_expr (code) {
    case E_FOO: "foo error!";
    case E_BAR: "bar error!";
    default: "unknown error!";
  });
}
</script>

<script>
  App.enrichContent({
    "Rust": "https://www.rust-lang.org",
    "Typedef": "http://www.embedded.com/electronics-blogs/programming-pointers/4024450/Tag-vs-Type-Names",
    "Decay": "http://www.drdobbs.com/architecture-and-design/cs-biggest-mistake/228701625",
    "Cello": "http://libcello.org/learn/a-fat-pointer-library",
    "Ternary": "https://en.wikipedia.org/wiki/%3F:",
    "CodingStandards":
    "https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard",
    "Typedef": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3515.pdf",
    "CQual": "http://www.cs.umd.edu/~jfoster/cqual/",
    "GccAlias": "https://gcc.gnu.org/onlinedocs/gcc-4.0.2/gcc/Type-Attributes.html",
    "StrictAliasing": "http://blog.regehr.org/archives/1307"
  });
</script> 
