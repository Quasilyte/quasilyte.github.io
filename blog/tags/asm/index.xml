<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Asm on Iskander Sharipov technical blog</title>
    <link>https://quasilyte.github.io/blog/tags/asm/</link>
    <description>Recent content in Asm on Iskander Sharipov technical blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 08 Jun 2018 13:29:13 +0300</lastBuildDate>
    
	<atom:link href="https://quasilyte.github.io/blog/tags/asm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Disassembling Go AVX-512</title>
      <link>https://quasilyte.github.io/blog/post/disassembling-go-avx512/</link>
      <pubDate>Fri, 08 Jun 2018 13:29:13 +0300</pubDate>
      
      <guid>https://quasilyte.github.io/blog/post/disassembling-go-avx512/</guid>
      <description>The problem Go 1.11 got updated assembler that supports AVX-512, but disassembler is left unchanged.
In other words, go tool asm speaks AVX-512, go tool objdump does not.
Suppose we have this avx.s file:
TEXT Â·avxCheck(SB), 0, $0 VPOR X0, X1, X2 //; AVX1 VPOR Y0, Y1, Y2 //; AVX2 VPORD.BCST (DX), Z1, K2, Z2 //; AVX-512 RET  You will be surprised after assemble+disassemble attempt:
$ go tool asm avx.</description>
    </item>
    
    <item>
      <title>Dispatch tables in Go asm</title>
      <link>https://quasilyte.github.io/blog/post/go-asm-dispatch-tables/</link>
      <pubDate>Thu, 31 May 2018 01:39:59 +0300</pubDate>
      
      <guid>https://quasilyte.github.io/blog/post/go-asm-dispatch-tables/</guid>
      <description>Dispatch tables When you want to execute particular code path depending on some kind of tag/opcode or other integer value that can be easily mapped into index, dispatch tables can speed things up compared to the sequence of comparisons and conditional jumps.
In interpreters, this technique is often used as an alternative to switch-based dispatch.
It&amp;rsquo;s called direct threading in that domain. Each opcode corresponds to table index that contains machine code address that can execute operation specified by the opcode.</description>
    </item>
    
    <item>
      <title>Go assembly language complementary reference</title>
      <link>https://quasilyte.github.io/blog/post/go-asm-complementary-reference/</link>
      <pubDate>Wed, 20 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://quasilyte.github.io/blog/post/go-asm-complementary-reference/</guid>
      <description>Third flavour of x86 assembly language This article is heavily inspired by AT&amp;amp;T VS Intel/Microsoft assembly syntax comparison page. It helped me very much in the past.
Many tools understand both AT&amp;amp;T and Intel style assembly. Go derived Plan9 toolchain, so you should learn third kind of assembly language. It will not accept anything else.
In this document:
 Comparison of Plan9/Go and AT&amp;amp;T/GNU assembly; Some non-obvious details that are not described anywhere else; Links to useful resources;  Check external resources for information that is missing here.</description>
    </item>
    
  </channel>
</rss>