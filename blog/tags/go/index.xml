<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on Iskander Sharipov technical blog</title>
    <link>https://quasilyte.github.io/blog/tags/go/</link>
    <description>Recent content in Go on Iskander Sharipov technical blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 31 May 2018 01:39:59 +0300</lastBuildDate>
    
	<atom:link href="https://quasilyte.github.io/blog/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Dispatch tables in Go asm</title>
      <link>https://quasilyte.github.io/blog/post/go-asm-dispatch-tables/</link>
      <pubDate>Thu, 31 May 2018 01:39:59 +0300</pubDate>
      
      <guid>https://quasilyte.github.io/blog/post/go-asm-dispatch-tables/</guid>
      <description>Dispatch tables When you want to execute particular code path depending on some kind of tag/opcode or other integer value that can be easily mapped into index, dispatch tables can speed things up compared to the sequence of comparisons and conditional jumps.
In interpreters, this technique is often used as an alternative to switch-based dispatch.
It&amp;rsquo;s called direct threading in that domain. Each opcode corresponds to table index that contains machine code address that can execute operation specified by the opcode.</description>
    </item>
    
    <item>
      <title>Goism objects layout model</title>
      <link>https://quasilyte.github.io/blog/post/goism-objects-layout-mode/</link>
      <pubDate>Sun, 14 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://quasilyte.github.io/blog/post/goism-objects-layout-mode/</guid>
      <description>Introduction Goism project requires Go pointers emulation inside Emacs Lisp code.
This document describes how to achive (almost) full functionality with potential to have optimizations that eliminate some of the emulation-related overhead.
The actual implementation can diverge. Only initial design is outlined.
Struct representation Go structures represented by lists.
Empty struct run-time value is unspecified, but it satisfies Go spec requirements.
type a1 struct { f1 int } // a1{1} // (list 1) type a2 struct { f1, f2, f3, f4 int } // a2{1, 2, 3, 4} // (list 1 2 3 4)  For the very small (1-3 fields) objects lists are a better choice than vectors, but generally, vectors are more memory-efficient and provide faster random access.</description>
    </item>
    
    <item>
      <title>Go assembly language complementary reference</title>
      <link>https://quasilyte.github.io/blog/post/go-asm-complementary-reference/</link>
      <pubDate>Wed, 20 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://quasilyte.github.io/blog/post/go-asm-complementary-reference/</guid>
      <description>Third flavour of x86 assembly language This article is heavily inspired by AT&amp;amp;T VS Intel/Microsoft assembly syntax comparison page. It helped me very much in the past.
Many tools understand both AT&amp;amp;T and Intel style assembly. Go derived Plan9 toolchain, so you should learn third kind of assembly language. It will not accept anything else.
In this document:
 Comparison of Plan9/Go and AT&amp;amp;T/GNU assembly; Some non-obvious details that are not described anywhere else; Links to useful resources;  Check external resources for information that is missing here.</description>
    </item>
    
    <item>
      <title>Go nested functions and static locals</title>
      <link>https://quasilyte.github.io/blog/post/go-nested-functions-and-static-locals/</link>
      <pubDate>Mon, 18 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://quasilyte.github.io/blog/post/go-nested-functions-and-static-locals/</guid>
      <description>Symbol visibility Default symbol visibility should be as narrow as possible. This means that you use globals with internal linkage instead of external, local variables rather than globals, hide class-related constants inside it&amp;rsquo;s scope, and so on.
If function is only called inside particular function, it should become a nested function.
Most of these rely on the language support.
Go has quite simple model of scopes and symbol visibility. User-defined identifier can be local or package-local (global).</description>
    </item>
    
    <item>
      <title>Path to convenient C FFI in Go</title>
      <link>https://quasilyte.github.io/blog/post/cgo-funcall/</link>
      <pubDate>Fri, 18 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://quasilyte.github.io/blog/post/cgo-funcall/</guid>
      <description>DWIM-style FFI CGo is a widely adopted way of calling C functions from Go: low level C FFI which does many things behind the scene, but exposes only minimal functionality that is required to interact with C.
CGo does no implicit conversions or data copying during C functions call, even int and C.int are not compatible. Code that uses this mechanism without wrappers (bindings) will be polluted with explicit slice/array copies and type conversions.</description>
    </item>
    
  </channel>
</rss>