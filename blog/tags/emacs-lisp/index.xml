<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Emacs Lisp on Quasilyte blog</title>
    <link>https://quasilyte.github.io/blog/tags/emacs-lisp/</link>
    <description>Recent content in Emacs Lisp on Quasilyte blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the MIT license.</copyright>
    <lastBuildDate>Sat, 23 Sep 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://quasilyte.github.io/blog/tags/emacs-lisp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Writing Emacs Lisp compiler intrinsics</title>
      <link>https://quasilyte.github.io/blog/post/writing-emacs-lisp-compiler-intrinsics/</link>
      <pubDate>Sat, 23 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://quasilyte.github.io/blog/post/writing-emacs-lisp-compiler-intrinsics/</guid>
      <description>The problem Given a particular programming task in Emacs Lisp, you almost always should implement it with function. Sometimes, macro is a proper tool.
Even more rarely, cl-define-compiler-macro may be your choice.
All these methods are safe to use. They almost certanly will not break with newer Emacs versions.
One interesting task that can not be implemented efficiently with approaches that are outlined above is imperative return statement.
Emacs Lisp lacks this kind of flow control and this is a problem we are goind to attack today.</description>
    </item>
    
    <item>
      <title>Emacs Lisp multi return values</title>
      <link>https://quasilyte.github.io/blog/post/elisp-multi-return-values/</link>
      <pubDate>Fri, 19 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://quasilyte.github.io/blog/post/elisp-multi-return-values/</guid>
      <description>The missing feature Did you ever wrote a function in Emacs Lisp which should return more than one result?
Emacs Lisp has no native support for multiple return values, but provides cl-lib that emulates it in a Common Lisp style.
In this article I will show that cl-values is suboptimal and can be replaced without any sacrifices to the convenience.
Naive solution cl-lib implements cl-values in terms of list. This approach is naive because each time you return with that, an allocation is involved.</description>
    </item>
    
  </channel>
</rss>