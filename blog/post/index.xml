<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Quasilyte blog</title>
    <link>https://quasilyte.github.io/blog/post/</link>
    <description>Recent content in Posts on Quasilyte blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the MIT license.</copyright>
    <lastBuildDate>Wed, 26 Apr 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://quasilyte.github.io/blog/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Dumbed-down Go interfaces</title>
      <link>https://quasilyte.github.io/blog/post/dumbing-down-go-interfaces/</link>
      <pubDate>Wed, 26 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://quasilyte.github.io/blog/post/dumbing-down-go-interfaces/</guid>
      <description>io.Writer If you write Go, odds are high that you familiar with io.Writer#Write signature well. Write returns both error and number of bytes written. Every time you call this method, error should be checked before you try to write to that writer again.
This interface is inconvenient to use when you want to call Write multiple times and get total number of bytes pushed during these invocations. You also do not want to loose error if it ever occurs.</description>
    </item>
    
    <item>
      <title>C broken defaults</title>
      <link>https://quasilyte.github.io/blog/post/c-broken-defaults/</link>
      <pubDate>Mon, 26 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://quasilyte.github.io/blog/post/c-broken-defaults/</guid>
      <description>State of the C C fits its niche quite well. If you want relatively simple, ubiquitous and efficient language there is no much room for selection.
It &amp;ldquo;evolves so slowly&amp;rdquo; because it is already quite complete. Most of the parts that can be improved without making C yet another bloated language require breaking changes.
 C could be designed better if we accept older code invalidation.
 &amp;hellip;but in reallity it is impossible to achieve.</description>
    </item>
    
  </channel>
</rss>