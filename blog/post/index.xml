<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Quasilyte blog</title>
    <link>https://quasilyte.github.io/blog/post/</link>
    <description>Recent content in Posts on Quasilyte blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the MIT license.</copyright>
    <lastBuildDate>Fri, 19 May 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://quasilyte.github.io/blog/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Emacs Lisp multi return values</title>
      <link>https://quasilyte.github.io/blog/post/elisp-multi-return-values/</link>
      <pubDate>Fri, 19 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://quasilyte.github.io/blog/post/elisp-multi-return-values/</guid>
      <description>The missing feature Did you ever wrote a function in Emacs Lisp which should return more than one result?
Emacs Lisp has no native support for multiple return values, but provides cl-lib that emulates it in a Common Lisp style.
In this article I will show that cl-values is suboptimal and can be replaced without any sacrifices to the convenience.
Naive solution cl-lib implements cl-values in terms of list. This approach is naive because each time you return with that, an allocation is involved.</description>
    </item>
    
    <item>
      <title>Dumbed-down Go interfaces</title>
      <link>https://quasilyte.github.io/blog/post/dumbing-down-go-interfaces/</link>
      <pubDate>Wed, 26 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://quasilyte.github.io/blog/post/dumbing-down-go-interfaces/</guid>
      <description>io.Writer If you write Go, odds are high that you familiar with io.Writer#Write signature well. Write returns both error and number of bytes written. Every time you call this method, error should be checked before you try to write to that writer again.
This interface is inconvenient to use when you want to call Write multiple times and get total number of bytes pushed during these invocations. You also do not want to loose error if it ever occurs.</description>
    </item>
    
    <item>
      <title>C broken defaults</title>
      <link>https://quasilyte.github.io/blog/post/c-broken-defaults/</link>
      <pubDate>Mon, 26 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://quasilyte.github.io/blog/post/c-broken-defaults/</guid>
      <description>State of the C C fits its niche quite well. If you want relatively simple, ubiquitous and efficient language there is no much room for selection.
It &amp;ldquo;evolves so slowly&amp;rdquo; because it is already quite complete. Most of the parts that can be improved without making C yet another bloated language require breaking changes.
 C could be designed better if we accept older code invalidation.
 &amp;hellip;but in reallity it is impossible to achieve.</description>
    </item>
    
  </channel>
</rss>