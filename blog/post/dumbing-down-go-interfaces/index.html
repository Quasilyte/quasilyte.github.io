<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <title>Dumbed-down Go interfaces &middot; Quasilyte blog</title>
    <meta name="author" content="Iskander Sharipov">
    <meta name="description" content="Technical blog about programming and related topics">
    <meta name="generator" content="Hugo 0.20.5" />
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <!-- RSS autodiscovery -->
    

    <link rel="shortcut icon" href="https://quasilyte.github.io/blog/img/favicon.ico">
    <link rel="stylesheet" href="https://quasilyte.github.io/blog/normalize.css">

    <!-- Stylesheets -->
    <link rel="stylesheet" href="https://quasilyte.github.io/blog/css/screen.css">
    <link rel="stylesheet" href="https://quasilyte.github.io/blog/css/github.css">
    <link rel="stylesheet" href="https://quasilyte.github.io/blog/styles/hybrid.css">
    <link rel="stylesheet" href="https://quasilyte.github.io/blog/font-awesome.css">
    

    
    <link rel="shortcut icon" type="image/x-icon" href="https://quasilyte.github.io/blog/favicon.ico">
    <link rel="icon" type="image/x-icon" href="https://quasilyte.github.io/blog/favicon.ico">
    

    <!-- Stylesheet for theme color -->
    <style type="text/css">
    a, a:visited {color: #33cc99;}
    .pagination a {color: #33cc99;}
    .gist .gist-file .gist-meta a:visited {color: #33cc99 !important;}
    a:focus, a:hover {color: #178b6b;}
    h1.post-title a:focus, h1.post-title a:hover, h1.blog-title a:focus, h1.blog-title a:hover {color: #178b6b;}
    .older-posts:hover, .newer-posts:hover {color: #178b6b;}
</style>
</head>

<body class="home-template">
    <header id="site-head">
	
	<h1 class="blog-title"><a href="https://quasilyte.github.io/blog/">Quasilyte blog</a></h1>
	
	
	<h1 class="blog-subtitle"><strong>defun</strong> and <strong>define</strong> live here in harmony</h1>
	
</header>
    
    
    <main class="content" role="main">
    
<article class="post">
    <header>
        <h1 class="post-title">Dumbed-down Go interfaces</h1>
        <div class="post-meta">
            <time datetime="26 April 2017">
                26 April 2017
            </time>
        </div>
    </header>

    
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#io-writer">io.Writer</a></li><br>
<li><a href="#dumbing-it-down">Dumbing it down</a></li><br>
<li><a href="#without-manual-counting">Without manual counting</a></li><br>
<li><a href="#without-eager-error-handling">Without eager error handling</a></li><br>
<li><a href="#not-only-io-writer">Not only io.Writer</a></li><br>
</ul></li><br>
</ul>
</nav>
    
    <section class="post-content">
        

<h2 id="io-writer">io.Writer</h2>

<p>If you write Go, odds are high that you familiar with
<code>io.Writer#Write</code> signature well.
Write returns both error and number of bytes written.
Every time you call this method,
error should be checked before you
try to write to that writer again.</p>

<p>This interface is inconvenient to
use when you want to call <code>Write</code> multiple times and get
total number of bytes pushed during these invocations.
You also do not want to loose error if it ever occurs.</p>

<pre><code class="language-go">func f1(w io.Writer, s fmt.Stringer, parts [][]byte) (int, error) {
	written, err := w.Write([]byte(s.String()))
	if err != nil {
		return written, err
	}
	for _, part := range parts {
		n, err := w.Write(part)
		written += n
		if err != nil {
			return written, err
		}
	}
	return written, nil
}
</code></pre>

<p>The boilerplate of error propagation can be annoying,
Go has no things like <a href="https://doc.rust-lang.org/std/macro.try.html">try!</a>
in Rust, but it does not mean that there is no solutions.</p>

<h2 id="dumbing-it-down">Dumbing it down</h2>

<p>Code presented above can be considered idiomatic.
Error checking is explicit and in-place (near error occurrence).
It is OK when you have small amount of <code>f1</code>-like function,
there is nothing wrong in small code duplication.
When you reach your limit of DRY violation, consider
possible changes.</p>

<p>Except writing, we do two things in that function:
counting bytes and checking for errors.
To dumb down interface we need to wrap it in a type
that does additional job for us.</p>

<p>I will present two examples that simplify <code>f1</code> function.
First <code>f2</code> does not sacrifice anything but improvement is
slight. Second <code>f3</code> is more expressive,
but may not be always appropriate.</p>

<h2 id="without-manual-counting">Without manual counting</h2>

<p>If errors are more important than counting, we may wish to hide
obscuring code to concentrate on error handling.</p>

<pre><code class="language-go">type countingWriter struct {
	written int       // Accumulates 1st return value of Write.
	dst     io.Writer // Wrapped writer.
}

func (cw *countingWriter) WriteAndCount(p []byte) error {
	n, err := cw.dst.Write(p)
	cw.written += n
	return err
}
</code></pre>

<p>The benefits are:
less varibles in scope (no need for temporary <code>n</code>
and <code>written</code> accumulator), single return value
makes it easier to compose calls.</p>

<pre><code class="language-go">func f2(w io.Writer, s fmt.Stringer, parts [][]byte) (int, error) {
	cw := countingWriter{dst: w}
	err := cw.WriteAndCount([]byte(s.String()))
	if err != nil {
		return cw.written, err
	}
	for _, part := range parts {
		err := cw.WriteAndCount(part)
		if err != nil {
			return cw.written, err
		}
	}
	return cw.written, nil
}
</code></pre>

<h2 id="without-eager-error-handling">Without eager error handling</h2>

<p>Explicit error handling in <code>f1</code>,
after all, is not important.
That function does not try to fix error conditions,
it just passes them back to the caller.
In the end, <code>f1</code> does only one important thing:
it writes.
It is possible to make a write method that returns&hellip; nothing.</p>

<pre><code class="language-go">type safeWriter struct {
	err     error     // Error that occured during writing.
	written int       // Bytes written before the error occured.
	dst     io.Writer // Wrapped writer.
}

func (w *safeWriter) SafeWrite(p []byte) {
	if w.err != nil {
		return
	}
	n, err := w.dst.Write(p)
	w.err = err
	w.written += n
}
</code></pre>

<p>Note that even if we do not return an error,
we store it in the safeWriter.
When first error occurs, safeWriter will continue to look like
before, but consequent write calls are ignored.
After all operations we wish to execute are made,
we return an error (which can be nil) and
a total number of bytes written.</p>

<pre><code class="language-go">func f3(w io.Writer, s fmt.Stringer, parts [][]byte) (int, error) {
	sw := safeWriter{dst: w}
	sw.SafeWrite([]byte(s.String()))
	for _, part := range parts {
		sw.SafeWrite(part)
	}
	return sw.written, sw.err
}
</code></pre>

<blockquote>
<p>Not all errors require immediate handling, we use that fact in
safeWriter.</p>
</blockquote>

<h2 id="not-only-io-writer">Not only io.Writer</h2>

<p><code>io.Writer</code> was selected to show this wrapping technique
on concrete example, but it can be applied to any methods
that clobber code because of the contract it establish.</p>

<p>For <code>f1</code> it could be better to define <code>writeAll</code> that
takes <code>[][]byte</code> and does the looping inside.
It works, but the solution is less generic than <code>f3</code>
and probably less composable. The balance of
<strong>too concrete</strong> and <strong>over-abstract</strong> code is hard, so the decision
is always halfway subjective.</p>

    </section>

    
    <section class="post-tags" style="padding-bottom:60px;">
        <div class="post-meta tags">
            <i class="fa fa-fw fa-tag"></i>
            
                
                <a href="https://quasilyte.github.io/blog/tags/go">[go] </a>
            
                
                <a href="https://quasilyte.github.io/blog/tags/golang">[golang] </a>
            
                
                <a href="https://quasilyte.github.io/blog/tags/error-handling">[error handling] </a>
            
        </div>
    </section>
    
    
    <section class="share">
    <p class="backtotop"><a data-scroll href="#site-head"><i class="fa fa-lg fa-fw fa-angle-double-up"></i></a><a data-scroll class="backtotoptext" href="#site-head"> Back to top</a></p>
    <p class="info prompt">Share</p>
    <a href="http://twitter.com/share?text=Dumbed-down%20Go%20interfaces&url=https%3a%2f%2fquasilyte.github.io%2fblog%2fpost%2fdumbing-down-go-interfaces%2f" title="Share on Twitter"
        onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="fa fa-2x fa-fw fa-twitter-square"></i> <span class="hidden">Twitter</span>
    </a>
    <a href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fquasilyte.github.io%2fblog%2fpost%2fdumbing-down-go-interfaces%2f" title="Share on Facebook"
        onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <i class="fa fa-2x fa-fw fa-facebook-square" style="margin-left: -8px"></i> <span class="hidden">Facebook</span>
    </a>
    <a href="https://plus.google.com/share?url=https%3a%2f%2fquasilyte.github.io%2fblog%2fpost%2fdumbing-down-go-interfaces%2f" title="Share on Google+"
       onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <i class="fa fa-2x fa-fw fa-google-plus-square" style="margin-left: -8px"></i> <span class="hidden">Google+</span>
    </a>
</section>

    <footer class="post-footer">
        <section class="author">
    <div class="authorimage" style="background: url(https://quasilyte.github.io/blog/img/avatar.jpg)"></div>
    <h4>Iskander Sharipov</h4>
    <p class="bio">Lisper that lost in a gophers land</p>
    <p class="meta">
      
    </p>
</section>
    </footer>
    
</article>

    </main>

    <footer class="site-footer">
	<div class="inner">
		<section class="footer-social">
      
      
      <a href="//www.linkedin.com/in/quasilyte" target="_blank" title="linkedIn"><i class="fa fa-2x fa-fw fa-linkedin"></i> <span class="hidden">LinkedIn</span></a>&nbsp;
      
      
      
      
      
      <a href="//github.com/quasilyte" target="_blank" title="GitHub"><i class="fa fa-2x fa-fw fa-github"></i> <span class="hidden">GitHub</span></a>&nbsp;
      
      
      
      
  </section>

		<section class="copyright">&copy; 2017 <a href="https://quasilyte.github.io/blog/">Iskander Sharipov</a>. Released under the MIT license.</section>
	</div>
</footer>

    <script src="https://quasilyte.github.io/blog/jquery.min.js"></script>
<script src="https://quasilyte.github.io/blog/js/index.js"></script>
<script src="https://quasilyte.github.io/blog/js/smooth-scroll.min.js"></script>
<script src="https://quasilyte.github.io/blog/highlight.pack.js"></script>


<script>
    smoothScroll.init({
        speed: 800,
        easing: 'easeInOutCubic',
        updateURL: false,
        offset: 125,
    });
</script>
<script>hljs.initHighlightingOnLoad();</script>


</body>
</html>