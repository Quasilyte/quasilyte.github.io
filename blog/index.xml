<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Quasilyte blog</title>
    <link>https://quasilyte.github.io/blog/</link>
    <description>Recent content on Quasilyte blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the MIT license.</copyright>
    <lastBuildDate>Wed, 21 Jun 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://quasilyte.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>RISC-V: custom instruction and its simulation</title>
      <link>https://quasilyte.github.io/blog/post/riscv32-custom-instruction-and-its-simulation/</link>
      <pubDate>Wed, 21 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://quasilyte.github.io/blog/post/riscv32-custom-instruction-and-its-simulation/</guid>
      <description>Agenda This article shows how to add a new instruction to RISC-V and simulate it.
These topics are covered along the way:
 Whole GNU riscv toolchain installation; Implementation of a new instruction for spike RISC-V ISA simulator; Manual instruction encoding in C/C++; Custom instruction simulation (with visible output); [riscv32-]GCC plugin development;  You may find associated repository useful.
Many things can go wrong. Be prepared to fix upcoming issues by yourself.</description>
    </item>
    
    <item>
      <title>Emacs Lisp multi return values</title>
      <link>https://quasilyte.github.io/blog/post/elisp-multi-return-values/</link>
      <pubDate>Fri, 19 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://quasilyte.github.io/blog/post/elisp-multi-return-values/</guid>
      <description>The missing feature Did you ever wrote a function in Emacs Lisp which should return more than one result?
Emacs Lisp has no native support for multiple return values, but provides cl-lib that emulates it in a Common Lisp style.
In this article I will show that cl-values is suboptimal and can be replaced without any sacrifices to the convenience.
Naive solution cl-lib implements cl-values in terms of list. This approach is naive because each time you return with that, an allocation is involved.</description>
    </item>
    
    <item>
      <title>Dumbed-down Go interfaces</title>
      <link>https://quasilyte.github.io/blog/post/dumbing-down-go-interfaces/</link>
      <pubDate>Wed, 26 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://quasilyte.github.io/blog/post/dumbing-down-go-interfaces/</guid>
      <description>io.Writer If you write Go, odds are high that you familiar with io.Writer#Write signature well. Write returns both error and number of bytes written. Every time you call this method, error should be checked before you try to write to that writer again.
This interface is inconvenient to use when you want to call Write multiple times and get total number of bytes pushed during these invocations. You also do not want to loose error if it ever occurs.</description>
    </item>
    
    <item>
      <title>C broken defaults</title>
      <link>https://quasilyte.github.io/blog/post/c-broken-defaults/</link>
      <pubDate>Mon, 26 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://quasilyte.github.io/blog/post/c-broken-defaults/</guid>
      <description>State of the C C fits its niche quite well. If you want relatively simple, ubiquitous and efficient language there is no much room for selection.
It &amp;ldquo;evolves so slowly&amp;rdquo; because it is already quite complete. Most of the parts that can be improved without making C yet another bloated language require breaking changes.
 C could be designed better if we accept older code invalidation.
 &amp;hellip;but in reallity it is impossible to achieve.</description>
    </item>
    
  </channel>
</rss>